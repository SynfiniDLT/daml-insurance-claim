-- Copyright (c) 2022 ASX Operations Pty Ltd. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Main where

--------------------------------------------------------------------------------
import DA.List
import DA.Optional
import DA.Text
import Data
import DA.Numeric

import DA.Foldable
  ( mapA_
  )
import DA.Set
--------------------------------------------------------------------------------

template Customer
  with
    customer: Party
    customerDetails: CustomerDetails
  where
    signatory customer

    nonconsuming choice RequestPolicy : ContractId PolicyRequest 
      with 
        insurer: Party
        startDate : Date
        endDate : Date
        carDetails : VehicalDetails
        excess : ExcessLevel

      controller customer
        do create PolicyRequest 
            with 
              customer
              insurer 
              startDate
              endDate
              carDetails
              excess
              customerDetails

    nonconsuming choice LodgeClaim: ContractId FNOLRequest 
        with 
          policy: ContractId Policy
          myRego : Text
          location : Text
          description: Text
          otherDrivers :[ClaimFact]
        controller customer
        do 
          policyData <- fetch policy
          now <- getTime
          let myFact = Fact 
                with 
                  insurer = policyData.insurer
                  paymentParty = Some policyData.paymentParty
                  rego = myRego
                  excess = policyData.excessLevel
                  name = this.customerDetails.fullName
                  location = location
                  description = description
                          
          let otherFacts:[Fact] = map(\i -> Fact 
                                      with 
                                      insurer = i.insurer
                                      paymentParty = None
                                      excess = NA
                                      rego = i.rego
                                      name = i.name
                                      location = ""
                                      description = "") otherDrivers 

          let insurers = map(\i -> i.insurer ) otherDrivers
          create FNOLRequest 
            with 
              insurer = policyData.insurer
              policy = policy
              facts = myFact::otherFacts
              involvedInsurer = insurers
              customer = customer


template PolicyRequest
  with
    customer: Party
    insurer: Party
    startDate: Date
    endDate: Date
    carDetails: VehicalDetails
    customerDetails: CustomerDetails
    excess: ExcessLevel
  where
    signatory customer
    observer insurer

    choice ApprovePolicy : ContractId Policy 
        with 
        policyId: Text
        paymentParty : Party
      controller insurer 
        do 
          create Policy 
            with 
              policyId
              customer
              insurer
              paymentParty
              startDate
              endDate
              carDetails
              excessLevel = excess
              customerDetails = customerDetails
        
        
    choice RejectPolicy : ()
      controller insurer
        do return ()

template Policy
  with
    customer: Party
    insurer: Party
    paymentParty : Party
    policyId: Text
    carDetails : VehicalDetails
    startDate: Date
    endDate: Date
    excessLevel: ExcessLevel
    customerDetails: CustomerDetails
  where
    signatory customer, insurer
    ensure endDate > startDate
  
    choice Cancel : ()
      controller customer
      do return ()

    choice Revoke : ()
      controller insurer
      do return ()
      
template FNOLRequest
  with
    insurer : Party
    policy: ContractId Policy
    facts: [Fact]
    involvedInsurer: [Party]
    customer: Party
  where
    signatory customer
    observer insurer
    
    choice AcceptClaimRequest : ContractId FNOL
        with
          repairer : Party
        controller insurer 
        do
          create FNOL 
            with 
              customer = customer
              policy = policy
              claimInsurance= insurer
              involvedInsurer = fromList (insurer::involvedInsurer)
              factsAndCost = map(\i -> (i,0.00)) facts
              agreedInsurer = empty
              repairer = repairer
              claimAgainstParty = None

template FNOL
  with
    customer : Party
    repairer : Party
    policy: ContractId Policy
    claimInsurance : Party
    involvedInsurer : Set Party
    factsAndCost: [(Fact, Numeric 2)]
    agreedInsurer : Set Party
    claimAgainstParty : Optional Party
  where
    signatory claimInsurance,customer 
    observer involvedInsurer, repairer

    choice AddFact : ContractId FNOL 
      with
        fact : Fact
      controller fact.insurer
        do
          assertMsg "Unable to modify agreed claim" (agreedInsurer /= involvedInsurer)
          assertMsg "Invalid rego. Lenghth should be equal or less than 6 characters/digits" (DA.Text.length fact.rego <= 6)

          if isNone (find(\i -> (fst i).insurer == fact.insurer) factsAndCost) then 
            do
            create this with factsAndCost = (fact,0.00) :: this.factsAndCost, agreedInsurer=empty
          else
            do
            create this with factsAndCost = map(\i -> if (fst i).insurer == fact.insurer 
                                                      then (Fact 
                                                            with 
                                                              insurer = fact.insurer
                                                              paymentParty = fact.paymentParty
                                                              rego = fact.rego
                                                              name = fact.name
                                                              excess = fact.excess
                                                              location = fact.location
                                                              description = fact.description
                                                          , snd i) 
                                                      else i ) factsAndCost, agreedInsurer=empty
    choice AddCost : ContractId FNOL 
      with 
        cost : Numeric 2
        ins : Party
      controller repairer
        do
        assertMsg "Unable to modify agreed claim" (agreedInsurer /= involvedInsurer)

        let f = map(\i -> if ((fst i).insurer==ins) 
                          then (fst i, cost) 
                          else i ) this.factsAndCost
        create this with 
          factsAndCost = f
          agreedInsurer= empty
          
    choice AgreeOnWhoToPay : Either (ContractId ClaimSettlementRequest) (ContractId FNOL)
      with 
        insur: Party
        atFaultParty: Party
      controller insur
        do
        assertMsg "Unable to modify agreed claim" (agreedInsurer /= involvedInsurer)
        assertMsg ("Selected party " <> show atFaultParty <> "must from involved parties" <> show involvedInsurer) (member atFaultParty involvedInsurer)
        assertMsg ("Payment party missing") (isNone (findIndex(\i -> isNone (fst i).paymentParty ) factsAndCost))


        if  (isNone claimAgainstParty || atFaultParty/= fromSome claimAgainstParty) then
          do
              c <- create this 
                    with 
                      agreedInsurer = insert insur empty
                      claimAgainstParty = Some atFaultParty
              return (Right c)
        else 
          do
            if (member insur agreedInsurer) then
              do 
                a <- create this 
                      with agreedInsurer = agreedInsurer
                return (Right a)
            else
              do
                z <- create this with agreedInsurer = insert insur agreedInsurer
                if (insert insur agreedInsurer == involvedInsurer) then
                    do
                      let Some (fact, _) = find(\i -> (fst i).insurer == fromSome claimAgainstParty) factsAndCost

                      b <- create ClaimSettlementRequest 
                            with 
                              factsAndCost = factsAndCost
                              atFaultPair= (atFaultParty, fromSome fact.paymentParty )
                              claimInsurance = this.claimInsurance 
                              customer=this.customer
                              repairer = repairer
                      return (Left b)
                else
                    do
                      return (Right z)



template ClaimSettlementRequest
  with 
    factsAndCost : [(Fact, Numeric 2)]
    atFaultPair : (Party, Party)
    claimInsurance: Party
    customer: Party
    repairer: Party
  where
      signatory claimInsurance
      observer fst atFaultPair, snd atFaultPair

      choice AcceptClaimSettlementRequest : ContractId ClaimSettlement
        controller fst atFaultPair
        do          
          -- find the access amount
          let Some (fact,cost) = find (\i -> (fst i).insurer == claimInsurance) factsAndCost

          i1 <- do create PaymentInstruction 
                    with  
                      issuer = fst atFaultPair
                      payTo = fromSome fact.paymentParty
                      amount = cast (intToDecimal (fromEnum fact.excess)) : Numeric 2
                      customerName = show claimInsurance
                      comment = "Customer Excess"
                      paymentParty = snd atFaultPair

          i2 <- mapA(\i ->    
                  do 
                    create PaymentInstruction 
                      with 
                        payTo = fromSome (fst i).paymentParty
                        amount = (snd i)
                        customerName = show repairer <> " - " <>show (fst i).insurer
                        issuer = fst atFaultPair
                        comment = "Repair cost for " <> show (fst i).insurer 
                        paymentParty = snd atFaultPair
                  ) factsAndCost

          let involvedParties:[Party] = concat (mapA(\i -> [(fst i).insurer,fromSome (fst i).paymentParty] ) factsAndCost)
          create ClaimSettlement 
            with 
              claimSettlementRequest = this
              settled = Settled
              repairer = repairer
              paymentParty = snd atFaultPair
              invoices = i1::i2
              involedParties = fromList (customer :: involvedParties)


template ClaimSettlement
  with 
      claimSettlementRequest: ClaimSettlementRequest
      settled : SettlementLevel
      repairer : Party
      paymentParty : Party
      involedParties : Set Party 
      invoices : [ContractId PaymentInstruction]
  where
      signatory fst claimSettlementRequest.atFaultPair, claimSettlementRequest.claimInsurance
      observer repairer, involedParties

      choice CreatePayment : ContractId ClaimSettlement
        controller paymentParty
        do
          mapA_(\i -> 
                      do 
                        t <- fetch i 
                        create InsurancePayment 
                          with 
                            to = t.payTo
                            from = paymentParty
                            amount = t.amount
                            payerName = show paymentParty
                        ) invoices

          create this with settled = Paid

template InsurancePayment
  with
    from: Party
    to: Party
    payerName: Text
    amount: Numeric 2
  where
    signatory to
    observer from

template PaymentInstruction
  with
    issuer: Party
    payTo: Party
    customerName: Text
    amount: Numeric 2
    paymentParty : Party
    comment: Text
  where
    signatory issuer
    observer payTo, paymentParty

    choice Accept : ContractId InsurancePayment
      controller payTo
      do
        create InsurancePayment 
          with 
            from = paymentParty
            to = payTo
            payerName = show paymentParty
            amount = amount

